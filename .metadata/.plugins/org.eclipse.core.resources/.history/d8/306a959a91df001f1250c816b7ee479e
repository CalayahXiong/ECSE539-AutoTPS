package org.xtext.example.mydsl.analysis;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;

import org.xtext.example.mydsl.myDsl.AndCondition;
import org.xtext.example.mydsl.myDsl.ShiftCondition;
import org.xtext.example.mydsl.myDsl.PrimaryCondition;
import org.xtext.example.mydsl.myDsl.Comparison;
import org.xtext.example.mydsl.myDsl.Condition;
import org.xtext.example.mydsl.myDsl.DifficultyCondition;
import org.xtext.example.mydsl.myDsl.OrCondition;

import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.Task;
import org.xtext.example.mydsl.myDsl.Worker;
import org.xtext.example.mydsl.myDsl.Rule;
import org.xtext.example.mydsl.myDsl.SeniorityLevel;

import java.util.List;

public class AutoTPS {

    private Model model;

    public AutoTPS(Model model) {
        this.model = model;
    }

    public void assignTasks() {
        List<Task> tasks = model.getTasks();
        List<Worker> workers = model.getWorkers();
        List<Rule> rules = model.getRules();

        // task assignment logic
        for (Task task : tasks) {
            Worker assignedWorker = findWorkerForTask(task, workers, rules);
            if (assignedWorker != null) {
                System.out.println("Task " + task.getName() + " assigned to " + assignedWorker.getName());
            } else {
                System.out.println("No worker available for task " + task.getName());
            }
        }
    }

    private Worker findWorkerForTask(Task task, List<Worker> workers, List<Rule> rules) {
        // rule-based worker assignment logic
        for (Rule rule : rules) {
            if (ruleMatchesTask(rule, task)) {
                Worker worker = findAvailableWorker(workers, rule.getAssign());
                if (worker != null) {
                    return worker;
                }
            }
        }
        return null;
    }

    private boolean ruleMatchesTask(Rule rule, Task task) {
        // Get the condition from the rule
        Condition condition = rule.getCondition();

        // Evaluate the condition recursively
        return evaluateCondition(condition, task);
    }

    private boolean evaluateCondition(Condition condition, Task task) {
        if (condition instanceof OrCondition) {
            // Handle OR conditions
            OrCondition orCondition = (OrCondition) condition;
            return evaluateCondition(orCondition.getLeft(), task) || 
                   evaluateCondition(orCondition.getRight(), task);
        } else if (condition instanceof AndCondition) {
            // Handle AND conditions
            AndCondition andCondition = (AndCondition) condition;
            return evaluateCondition(andCondition.getLeft(), task) && 
                   evaluateCondition(andCondition.getRight(), task);
        } else if (condition instanceof Comparison) {
            // Handle comparison conditions (e.g., > 180 min)
            return evaluateComparison((Comparison) condition, task);
        } else if (condition instanceof ShiftCondition) {
            // Handle shift conditions (e.g., nightshift)
            return evaluateShiftCondition((ShiftCondition) condition, task);
        } else if (condition instanceof DifficultyCondition) {
            // Handle difficulty conditions (e.g., easy)
            return evaluateDifficultyCondition((DifficultyCondition) condition, task);
        } else {
            // Handle other conditions (e.g., parentheses)
            return evaluateCondition(((PrimaryCondition) condition).getCondition(), task);
        }
    }

    private boolean evaluateComparison(Comparison comparison, Task task) {
        String attribute = comparison.getAttribute();
        String operator = comparison.getOperator();
        int value = comparison.getValue();

        if (attribute.equals("duration")) {
            int taskDuration = task.getDuration();
            switch (operator) {
                case ">":
                    return taskDuration > value;
                case "<":
                    return taskDuration < value;
                case ">=":
                    return taskDuration >= value;
                case "<=":
                    return taskDuration <= value;
                case "=":
                    return taskDuration == value;
                default:
                    throw new IllegalArgumentException("Invalid operator: " + operator);
            }
        } else {
            throw new IllegalArgumentException("Invalid attribute for comparison: " + attribute);
        }
    }

    private boolean evaluateShiftCondition(ShiftCondition shiftCondition, Task task) {
        String shift = shiftCondition.getShift();
        String taskShift = getTaskShift(task.getStart().toString());

        return shift.equals(taskShift);
    }

    private boolean evaluateDifficultyCondition(DifficultyCondition difficultyCondition, Task task) {
        String difficulty = difficultyCondition.getDifficulty().toString();
        return difficulty.equals(task.getDifficulty().toString().toLowerCase());
    }

    private String getTaskShift(String startTime) {
        // Parse the start time (HH:MM) and determine the shift
        String[] parts = startTime.split(":");
        int hours = Integer.parseInt(parts[0]);

        if (hours >= 6 && hours < 14) {
            return "dayshift";
        } else if (hours >= 14 && hours < 22) {
            return "eveningshift";
        } else {
            return "nightshift";
        }
    }

    private Worker findAvailableWorker(List<Worker> workers, SeniorityLevel seniorityLevel) {
        //  worker availability logic
        for (Worker worker : workers) {
            if (worker.getSeniority().equals(seniorityLevel) && worker.getIsActive().equals("True")) {
                return worker;
            }
        }
        return null;
    }

    public static void main(String[] args) {
        // Load the TPS model 
        Model model = loadModel("../data/tasks.tps");

        // Create and run the AutoTPS tool
        AutoTPS autoTPS = new AutoTPS(model);
        autoTPS.assignTasks();
    }

    private static Model loadModel(String filePath) {
        // Implement model loading logic
    	ResourceSet resourceSet = new ResourceSetImpl();
    	Resource resource = resourceSet.getResource(URI.createFileURI(filePath), true);
    	Model model = (Model) resource.getContents().get(0);
        return null; 
    }
}
